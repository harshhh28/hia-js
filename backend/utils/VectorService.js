import { HfInference } from "@huggingface/inference";
import { VectorEmbedding } from "../models/VectorEmbedding.js";
import { FallbackEmbeddingService } from "./FallbackEmbeddingService.js";
import fs from "fs";
import path from "path";

export class VectorService {
  constructor() {
    // Use Hugging Face Inference API directly
    this.hf = new HfInference(process.env.HUGGINGFACE_API_KEY);
    this.model = "sentence-transformers/all-MiniLM-L6-v2";
    this.dimensions = 384;
    this.useFallback = false;

    // If no API key, use fallback embeddings
    if (!process.env.HUGGINGFACE_API_KEY) {
      this.fallbackService = new FallbackEmbeddingService();
      this.useFallback = true;
    }
  }

  async createEmbedding(text) {
    try {
      if (this.useFallback) {
        return await this.fallbackService.createEmbedding(text);
      }

      // Use Hugging Face Inference API directly
      const result = await this.hf.featureExtraction({
        model: this.model,
        inputs: text,
      });

      return result;
    } catch (error) {
      console.error("Error creating embedding:", error);

      // If Hugging Face fails and we're not already using fallback, try fallback
      if (!this.useFallback) {
        this.fallbackService = new FallbackEmbeddingService();
        this.useFallback = true;
        return await this.fallbackService.createEmbedding(text);
      }

      throw error;
    }
  }

  async storeMedicalReportEmbeddings(sessionId, medicalReportText, analysis) {
    try {
      // Split the medical report into chunks for better retrieval
      const chunks = this.splitTextIntoChunks(medicalReportText, 1000);

      // Store each chunk as an embedding
      for (let i = 0; i < chunks.length; i++) {
        const chunk = chunks[i];
        const embedding = await this.createEmbedding(chunk);

        await VectorEmbedding.create({
          session_id: sessionId,
          content: chunk,
          embedding: embedding,
          metadata: {
            type: "medical_report",
            chunk_index: i,
            total_chunks: chunks.length,
          },
        });
      }

      // Store the analysis as well
      const analysisEmbedding = await this.createEmbedding(analysis);
      await VectorEmbedding.create({
        session_id: sessionId,
        content: analysis,
        embedding: analysisEmbedding,
        metadata: {
          type: "medical_analysis",
        },
      });
    } catch (error) {
      console.error("Error storing medical report embeddings:", error);
      throw error;
    }
  }

  async findRelevantContext(sessionId, query, limit = 5) {
    try {
      const queryEmbedding = await this.createEmbedding(query);
      const similarEmbeddings = await VectorEmbedding.findSimilar(
        queryEmbedding,
        sessionId,
        limit
      );

      return similarEmbeddings.map((embedding) => ({
        content: embedding.content,
        metadata: embedding.metadata,
        distance: embedding.distance,
      }));
    } catch (error) {
      console.error("Error finding relevant context:", error);
      throw error;
    }
  }

  async getContextualPrompt(sessionId, userQuery) {
    try {
      const relevantContext = await this.findRelevantContext(
        sessionId,
        userQuery
      );

      if (relevantContext.length === 0) {
        return userQuery;
      }

      const contextText = relevantContext
        .map((ctx) => ctx.content)
        .join("\n\n");

      return `You are a medical assistant specialized in health and medical topics only.

IMPORTANT: You can ONLY respond to medical and health-related questions. If the user asks about non-medical topics (like technology, cooking, travel, entertainment, etc.), politely decline and redirect them to ask medical questions instead.

Based on the medical report and analysis provided earlier, please answer the following question:

Medical Report Context:
${contextText}

User Question: ${userQuery}

Please provide a detailed medical answer based on the medical information provided, maintaining consistency with the previous analysis.

CRITICAL INSTRUCTION: You MUST respond in PLAIN TEXT format only. Do NOT use any markdown formatting, asterisks (*), underscores (_), bold text (**), italics, bullet points (-), or any special formatting characters. Use only simple text with line breaks for readability. Never use ** or any markdown syntax.

DISCLAIMER: This response is generated by AI and should not be considered as a replacement for professional medical advice. Please consult with a healthcare provider for proper medical diagnosis and treatment.`;
    } catch (error) {
      console.error("Error creating contextual prompt:", error);
      return userQuery; // Fallback to original query
    }
  }

  splitTextIntoChunks(text, chunkSize = 1000) {
    const words = text.split(/\s+/);
    const chunks = [];

    for (let i = 0; i < words.length; i += chunkSize) {
      const chunk = words.slice(i, i + chunkSize).join(" ");
      chunks.push(chunk);
    }

    return chunks;
  }

  async cleanupSessionEmbeddings(sessionId) {
    try {
      await VectorEmbedding.deleteBySessionId(sessionId);
    } catch (error) {
      console.error("Error cleaning up session embeddings:", error);
      throw error;
    }
  }
}

// Logging utility
export class Logger {
  static logToFile(message, level = "INFO") {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${level}: ${message}\n`;

    const logDir = path.join(process.cwd(), "logs");
    const logFile = path.join(
      logDir,
      `hia-${new Date().toISOString().split("T")[0]}.log`
    );

    try {
      // Ensure logs directory exists
      if (!fs.existsSync(logDir)) {
        fs.mkdirSync(logDir, { recursive: true });
      }

      fs.appendFileSync(logFile, logEntry);
    } catch (error) {
      console.error("Error writing to log file:", error);
    }
  }

  static logError(error, context = "") {
    const message = context ? `${context}: ${error.message}` : error.message;
    this.logToFile(message, "ERROR");
    console.error(message, error);
  }

  static logInfo(message) {
    this.logToFile(message, "INFO");
  }
}
